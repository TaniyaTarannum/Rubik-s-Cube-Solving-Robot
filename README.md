# Rubik-s-Cube-Solving-Robot
# Introduction
RISC (Reduced Instruction Set Computer) is a computer ISA on the rise in today‚Äôs computer design. It provides multiple benefits over the conventional CISC (Complex Instruction Set Computer), the major ones being customisability and pipelining (which is possible due to the execution of different instructions being similar to each other). This project uses the ZedBoard FPGA(Field-Programmable Gate Array), on which the Potato Processor is implemented and used by programming it using Assembly Language (compatible with the RV32I ISA). The project‚Äôs final deliverable is a Rubik‚Äôs Cube Solving Robot, which is also designed & manufactured under this project and controlled by The Potato Processor (implemented on ZedBoard). Potato Processor, an open-source RISC-V processor by Kristian Klomsten Skordal.

# Understanding the Processor
The core of the Potato Processor SoC is a 32-bit microprocessor. It follows the RV32I standardized ISA. This core communicates with the other SoC constituents over the wishbone interface.

## ALU  
The Arithmetic and Logic Unit in the Potato Processor primarily consists of three entities: the ALU (pp_alu.vhd), which performs the calculations, the ALU Control Unit (pp_alu_control_unit.vhd), which generates the controlling signals for the ALU, the ALU Multiplexer (pp_alu_mux.vhd) which multiplexes both the inputs to the ALU.   
The ALU takes two 32-bit inputs (operands) and generates a 32-bit output (result) based on another input named operation of the type alu_operation. These custom types have been defined in a separate VHDL source file named pp_types.vhd. The 32-bit operand inputs are provided by the ALU muxes, and the operation is provided by the ALU control unit.  

The ALU multiplexer generates the 32-bit operand as an output and sends it as input to the ALU. For generating this, it takes multiple inputs which are to be multiplexed (register value, immediate, value, pc value, etc.) and a selecting input (generated by the ALU control unit) of the type alu_operand_source, which can be found in the pp_types.vhd file.  

The ALU control unit takes the instruction as inputs in three fragments: opcode (5-bit), funct3 (3-bit), and funct5 (5-bit). Then it generates three outputs ‚Äì two signals (of the type alu_operand_source, which can be found in pp_types.vhd) to select the ALU input operand in the multiplexer, and the other is a type of operation the ALU must perform. The instructions in RV32I are 32 bits long. 

The distribution of instruction contents is: opcode ‚Äì 7 bits (but the two LSBs are both 1, so they are not checked by the ALU control unit, which thus takes a 5-bit opcode as input), 3 bits funct3 & 7 bits funct7 (additional information about the instruction), the rest 15 bits of data can be either 3 register addresses (5 bits each), immediate values (12 bits), shift amount, etc. The integration & coordination of all these signals is done by the Instruction Fetch, Decode & Execute Entities.  

## Fetch, Decode & Execute   
The three steps ‚Äì fetch, decode, and execute- are standard and well-known for running instructions. 

The first step is to fetch an instruction from the instruction 
memory. This is done by the Instruction Fetch Entity (pp_feetch.vhd). It takes the following inputs: basic inputs - clk, reset; control inputs ‚Äì stall, flush, branch, exception, branch_target. It communicates with the instruction memory ‚Äì generates memory address (32-bit) and memory request (1-bit) as output, and takes memory data (32-bit) and memory acknowledgement (1-bit) as input. The final outputs that it generates are given to the Instruction Decode Entity (pp_decode.vhd). The Instruction Fetch Entity is responsible for updating the program counter as per requirement (sequential execution or jump/branch execution); it begins the fetching of instructions from the Reset Address specified in the toplevel file (where the SoC is defined, and its components are instantiated). 

The second step is to decode the instruction read from the 
instruction memory, done by the Instruction Decode Entity (pp_decode.vhd). It takes basic inputs ‚Äì clk, reset; control inputs ‚Äì flush, stall; inputs from the Instruction Fetch Entity ‚Äì instruction data (32-bit), instruction address (32-bit), instruction ready (1-bit status), instruction count (1-bit status). Using these, it generates various outputs: address outputs - registers (2 sources and 1 destination), program counter; control ‚Äì write enable, alu_operation, memory_operation, branch, ALU source, etc.; it also generates exception status signals. All these outputs are generated from the instruction data input according to the standards of RV32I. 

The final step is to execute the decoded instruction, which is done by the Instruction Execute Entity (pp_execute.vhd). It takes basic inputs ‚Äì clk, reset; control inputs ‚Äì flush, stall; generates outputs for the data memory (address, data, data size, read & write requests), outputs for the destination register (register address and data), and handles jump instruction calculations. It is responsible for updating the CSR (Control Status Register), instantiating the ALU multiplexers, the ALU itself, and the CSR ALU. The pipeline registers in the processor are also defined in the Instruction Execute Entity.   

## Register File   
The register file has 32 32-bit registers, all initialised to zero. The zeroth register (R0) data is fixed to zero and can‚Äôt be updated. The data of all the registers can be updated. The register file takes the clock as an input; it has two read ports (thus 2 address inputs and 2 data outputs) and one write port (1 address input, 1 data input and 1 write enable input).   

## Writeback    
In pipelined architectures, writeback is responsible for updating the data at the destination register in the register file and the CSR; this is one with each clock cycle while reset is inactive. This is done by defining a pipeline register.   

## Clock Generator   
The Zed board FPGA has an on-board clock with a frequency of 100 MHz, and the potato core can operate at a maximum 50 MHz frequency[2] (limited by the slacks found in the STA of implemented design) so to reduce the in-built clock of FPGA, a design is to be added that reduces the frequency by half. This is the Clock Generator entity (clock_generator.vhd) that is being instantiated in the top-level design where clk is the input clock frequency (100 MHz), and system_clk is the clock that is 
used to operate the processor‚Äôs core and locked is a signal which signifies that the clock is stable after the edges it acts as an acknowledge to the design that the input clock is stable.  

## GPIO Module  
This processor has a General-Purpose Input Output Module, which can be used to output or input digital signals. The GPIO Module used in this design is memory mapped and has three memory locations for one GPIO module, namely ‚Äì input register (at base address + 0x00), output register (at base address + 0x04), direction register (at base address + 0x08). The number of GPIO bits to be used is configurable (with a maximum of 32 in one module, though multiple modules can be instantiated). The base address is to be defined in the toplevel (SoC) file; for now, let us assume that to be 0xC0004000; this will be referred to as the GPIO-0 Module base address in the forthcoming parts. Input Register is at 0xC0004000: a read-only memory location which is updated as per the inputs given from the GPIO input pins. The Output Register is at 0xC0004004: a read/write memory location, the data written here is sent as output to the GPIO output pins. Direction Register is at 0xC0004008: a read/write memory location used to configure the GPIO pins as input or output. To set a bit of the GPIO as input, the corresponding bit in the Direction Register is set to 0, whereas to set a bit of the GPIO 
as output, the corresponding bit in the Direction Register is set to 

## UART Module
UART (Universal Asynchronous Receiver/Transmitter) is a well-known serial digital communication protocol; this can be used to boot-load new programs and for other purposes like communicating with a serial monitor. The Potato Processor supports UART as a memory-mapped module and has five memory locations for one UART module, namely ‚Äì transmit 
register (at base address + 0x00), receive register (at base address + 0x04), status register (at base address + 0x08), sample clock divisor register (at base address + 0x0C) and interrupt enable register (at base address + 0x10). The base address is to be defined in the toplevel (SoC) file; for now let us assume that to be 0xC0003000; we‚Äôll refer this to as the UART-1 Module base address in the forthcoming parts.  
Transmit Register is at 0xC0003000: a write-only memory location that stores the data sent over the corresponding UART module.   
Receive Register is at 0xC0003004: a read-only memory location, which stores the data received over the corresponding UART module.   
Status Register is at 0xC0003008: a read-only memory location, which contains 4 bits of useful information ‚Äì bit 0 signifies receive buffer empty status, bit 1 signifies transmit buffer empty status, bit 2 signifies receive buffer full status, bit 3 signifies transmit buffer full status.   
Sample Clock Divisor Register is at 0xC000300C: a read-write memory location, which stores the value of the sample clock divisor that decides the baud rate of the corresponding UART module, which is given by:   

Sùëéùëöùëùùëôùëí ùê∂ùëôùëúùëêùëò ùê∑ùëñùë£ùëñùë†ùëúùëü = (ùëÜùë¶ùë†ùë°ùëíùëö ùê∂ùëôùëúùëêùëò / ùêµùëéùë¢ùëëùëüùëéùë°ùëí ‚àó 16)‚àí1   
Interrupt Enable Register is at 0xC0003010: a read-write memory location, which is used to configure if the corresponding UART module is receiving or transmitting data ‚Äì bit 0 is set to receive data, bit 1 is set to transmit data. 

## Memory Module
The memory module is the entity instantiated to define the SoC‚Äôs main memory and the Random Access Memory (AEE RAM ‚Äì Application Execution Environment RAM). It is an array of memory locations (each 4 bytes long), the default size is 4096 bytes (1024 memory locations) which can be customized while instantiating in the toplevel (SoC) file, as per requirement. The system clock and reset are taken as input, and communication is done over the Wishbone interface. 

## AEE ROM Module
AEE stands for Application Execution Environment, the environment where the primary application is stored, which is executed when the processor is reset (i.e., stored at Reset Address). This application can be anything but is conventionally a configuration program like a bootloader or an 
operating system.  

## Bootloader
A bootloader is a program that loads instructions into the instruction memory when a processor is booted (powered on) or reset. It thus provides the customisability (programmability) in the processor rather than the hard-coding the instruction memory ‚Äì therefore saving time and resources. The bootloader designed for this project (coded in assembly language) takes instructions over the UART-1 Module, each UART Packet being a byte long, with 4 bits of useful data (excluding start, stop, and parity bits) in little-endian format. After the bootloading has been done, it jumps the program counter to 0x00000000 and starts executing the thus bootloaded program. 
## Wishbone Module   
The wishbone protocol/bus is an open-source protocol that specifies rules for a logic bus (not the electrical information or bus topology), specially designed for communication between different modules/entities on a single chip. The Potato Processor also uses a wishbone interface to establish communication between modules inside the SoC.
## System on Chip (SoC)  
The system is designed to fit on a single chip, which is defined in the toplevel file. This file instantiates all the major modules, including the ones explained above ‚Äì reset controller, clock generator, processor core, one GPIO Module (GPIO-0), two UART Modules (UART-0, UART-1), two memory modules (main memory ‚Äì 128kB, AEE RAM ‚Äì 16kB), AEE ROM ‚Äì 16kB.   
The memory layout is customisable and currently is as follows:  
| Starting Address | Memory Element |
|--|--|
| 0x00000000 | Main memory (128 kB) |
| 0xC0002000 | UART0 | 
| 0xC0003000 | UART0 | 
| 0xC0004000 | GPIO0 |
| 0xFFFF8000 | Application execution environment ROM (16 kB) |
| 0xFFFFC000 | Application execution environment RAM (16 kB) |    

Memory mapping is used by the address decoder, which is the main functional part of the toplevel file. The address decoder takes the address from the processor core and, on that basis, decides which of the peripherals is to be selected. The address decoder needs to be updated if the memory layout is to be changed. 

## Functioning of SoC  
The functioning of SoC comes from the definition of the entities as explained above; all the toplevel file does is instantiate these entities and define the interconnections between them over the Wishbone interface.  
<p align="center">
  <img src="https://github.com/user-attachments/assets/c01d3564-4718-4916-bf65-844831eba6fe">
</p>
<p align="center">Toplevel Diagram of Potato Processor SoC</p>   

# CFOP Algorithm
The program to solve the Rubik's Cube is written in C++ and is based on the CFOP algorithm, which defines a series of moves based on the face patterns of the cube. The algorithm involves rotating the six faces of the cube either in a clockwise or an anticlockwise direction. In our code, for a face centered with, say, yellow, Y0 and Y1 are used to represent clockwise and anticlockwise rotations of the yellow-centered face, respectively.  
<p align="center">
  <img src="https://github.com/user-attachments/assets/1be01b42-d005-41dd-8a1d-54243953b724" width="500">
</p>
<p align="center">Numbering scheme for Rubik's cube</p>   

The cube's initial configuration is provided in the form of a 2D array of size 6√ó9, where each row represents one face of the cube. The rows are ordered to store data in the following sequence of faces: White, Green, Orange, Blue, Red, and Yellow. This matrix is updated after each move, based on the algorithm, until the cube is fully solved. 

### Understanding the CFOP Algorithm  
This algorithm follows the following steps: CFOP stands for Cross, First Two Layers (F2L), Orientation of Last Layer (OLL), and Permutation of Last Layer (PLL).
Firstly, a cross is formed. In our program, the face with the white center is chosen as the first layer. Using if-else statements and swap functions, this step is executed and is referred to as the Cross. Secondly, the program proceeds to the next step, F2L, in two parts. It first completes the white face and then the second layer by performing simple rotations of the cube's faces in clockwise (CW) or anticlockwise (ACW) directions. Next, the program advances to OLL, solving the yellow face by first forming a yellow cross and then completing the entire layer. Finally, it moves to the last step, PLL, where at least two yellow corners are positioned correctly, and then the rest of the cube is solved by following the fixed steps of the algorithm.  

## Robot's Configuration  
Nema-17 stepper motors[6] and DRV8825 Stepper Motor Driver Modules[5] have been used in the project to actuate the rotation of Rubik‚Äôs Cube‚Äôs faces. The precise open-loop control of stepper motors was the reason for choosing them for this project since they can provide exact turns of 90¬∫ without any closed-loop control (use of sensors).   
The figure below shows a typical connection schematic for DRV8825 Stepper Motor Driver Modules.  
<p align="center">
  <img src="https://github.com/user-attachments/assets/df079555-1ca6-44d1-87c6-4c88bb9c7eec" width="500">
</p>
<p align="center">Typical Connection Schematic for DRV8825</p>   

The robot uses 6 stepper motors, one for each of the 6 faces. Each stepper motor has a dedicated motor driver. The 6 motor drivers share the same power supply lines (VMOT, GND), the same control lines (STEP, DIR) and the same low voltage supply (RESET, SUPPLY ‚Äì which are at Vcc provided by the PMOD connector on ZedBoard and GND ‚Äì which is connected to GND provided by the PMOD connector on ZedBoard). The 6 enable signals originating from the ZedBoard are connected to each of the 6 motor drivers, which enables a single motor driver at a time, thus rotating the corresponding face; this scheme also helps in reducing the current consumption of the robot by 83% (as compared to all the motors being active all the time with different step inputs). The controlling circuit has been assembled on a breadboard; the schematic in Figure 11 better explains the connections.   
<p align="center">
  <img src="https://github.com/user-attachments/assets/b4fad52f-cf89-480b-a949-7029dd7683c4" width="500">
</p>
<p align="center">Controller Schematic for Robot</p>   
All 6 stepper motors are mounted on a 3D-printed PLA structure, which holds the Rubik's Cube along with these stepper motors. This structure has been designed using Solidworks Software[8], and its CAD can be seen in the figure below: 
<p align="center">
  <img src="https://github.com/user-attachments/assets/88e2d653-bbeb-4159-a19c-98d8873bd480" width="500">
</p>
<p align="center">CAD for Robot Body in Solidworks</p>  

## Simulation  
After the SoC file has been created, it is implemented on the ZedBoard. For implementation, timing constraints need to be met, which was done by designing a custom clock generator. The next step is defining constraints in the ZedBoard for inputs and outputs, which requires deciding what outputs and inputs are needed to operate the Cube Solving Robot.   To control the robot, we need to control 6 Stepper Motors (NEMA-17 motors) controlled by DRV8825 modules. The 6-stepper motors will have a dedicated motor driver for each of them, to select which motor to be rotated, an Active Low Enable signal will be sent to the required motor driver ‚Äì so, this requires 6 bits of digital output data; next, a single bit of output is required to determine the direction of rotation of the motor; another bit to generate the pulses to rotate Stepper Motors. Hence, a total of 8 bits of output is required, with the following layout:
| Bits 7-2 | Bit 1 | Bit 0 |
|--|--|--|
| Enable Motor (5,4,3,2,1,0) | Direction | Step Pulse |  

This will be achieved by using GPIOs. To give a visual indication to inform the user about the current move, the 8 LEDs on the ZedBoard will be used to show the current 8 Control Bits being sent to the robot. Thus, a total of 16 GPIOs (all configured as output) are being used. The GPIO outputs (other than LEDs) are taken from an On
Board PMOD connector, which also provides Vcc (Pin 6 & Pin12) and GND (Pin 5 & Pin 11) required for the stepper motor drivers. The processor also has a reset button, which also needs to be provided on the ZedBoard to reset the processor whenever needed. This is also achieved by defining constraints. The project does not currently require UART Modules; thus, their constraints have not been shown in this report.

| Port | Function | Constraint | 
|--|--|--|
| gpio_pins[0] | Step Pulse LED | T22 (LED-0) |
| gpio_pins[1] | Direction LED | T21 (LED-1) |
| gpio_pins[2] | Yellow Face LED | U22 (LED-2) | 
| gpio_pins[3] | Red Face LED | U21 (LED-3) |
| gpio_pins[4] | Blue Face LED | V22 (LED-4) |
| gpio_pins[5] | Orange Face LED | W22 (LED-5) |
| gpio_pins[6] | Green Face LED | U19 (LED-6) |
| gpio_pins[7] | White Face LED | U14 (LED-7) |
| gpio_pins[8] | Step Pulse Output | Y11 (JA-1) |
| gpio_pins[9] | Direction Output | AA11 (JA-2) |
| gpio_pins[10] | Yellow Face Output | Y10 (JA-3) |
| gpio_pins[11] | Red Face Output | AA9 (JA-4) |
| gpio_pins[12] | Blue Face Output | AB11 (JA-7) |
| gpio_pins[13] | Orange Face Output | AB10 (JA-8) | 
| gpio_pins[14] | Green Face Output | AB9 (JA-9) |
| gpio_pins[15] | White Face Output | AA8 (JA-10) |
| reset_n | Reset the Button of SoC | P16 (Push Button BTNC) |    

In the above table, face LED/Face Output symbolised the enable signal for the motor driver of the corresponding face. 
<p align="center">
  <img src="https://github.com/user-attachments/assets/26ce9868-f27a-400a-b86c-b3a9d6585910" width="500">
</p>
<p align="center">Robot Controller Implemented using Breadboard</p>  
<p align="center">
  <img src="https://github.com/user-attachments/assets/cb8ace65-c7af-4d6d-abc8-17a8f4d6a1ef" width="500">
</p>
<p align="center">The Robot - showing 3D-Printed Body, Stepper Motors and Rubik's Cube </p>  

## Conclusion
The project‚Äôs primary goal, which was to understand and implement a RISC-V processor[1] on FPGA, has been achieved successfully. In addition, a Rubik‚Äôs Cube solving robot was successfully controlled by the processor, which also generated the actuating commands for the Robot. This project not only proves the future applications and scalability of RISC-based processors because of their customizability but also proves the ease of use since RISC provides the possibility of soft-core processors. This is facilitated by RISC-V, which is a Reduced ISA and is open-source for further development and research. 
